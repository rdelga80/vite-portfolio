---
title: Be a Code Collaborator, Not a Code Executioner
description: Building a better relationship with other developers on your team
tags: programming,engineering,code review,psychology of dev
date: February 8, 2024
---

### tl:dr

When you review a PR and come across something that doesn't seem right which mindset do you follow:

1. This is wrong and I need to correct it, or
2. This doesn't look right, but maybe I'm missing something? Let me reach out to the dev.

If you have a team of the first your team culture will be toxic.

If you have the second your team culture will be collaborative.

---

I've been thinking a lot lately about the essence of the job of being a Software Engineer.

Part of this is born from how people _always_ react when I tell them that it's my profession, and they inevitably respond, _"I couldn't do it, I'm not very good at math."_

This is a weird thing for someone to say because the extend of the math I ever deal with is looking up the proper syntax for `Math.random()`.

On the other hand, I also have been thinking about my personal experiences as a Software Engineer and what matters to me on a day to day basis. I like to compare that versus what other people in the field describe what the role is supposed to be.

Technically, this is obviously a technical job. On a daily basis we are interacting with computers, servers, and databases. Sometimes you need to draw on a depth of knowledge that might include render and load times, or how a Big O will effect smartphones running on a 3G network.

Many developers, and the worst perpetrated stereotypes of us, are a group of people who are over detailed about computers and are more than happy to vomit that knowledge on anyone within a 3 mile radius while tipping their fedoras with a subtle wink insinuating _yes, I do know more than you._

But personally, I disagree that this is what it means to be a software engineer, and I reject this association.

While working with my team's designer the other day I told her how much I dislike computers, and that the digital age is going to be one of humanity's biggest mistakes. She was surprise and couldn't imagine a software engineer thinking this way.

Yes, I may use a computer to do my job, but computers are the last thing that matter to this role.

Not to sidetrack but it's why I'm not threatened by the the emergence of artificial general intelligence. I welcome it specifically because it'll open the possibilities of anyone and everyone to make their own web and software applications and make it a less welcoming place for the previously mentioned fedora tipping know-it-all.

This job is less about technology, which may be the _tool_ we use, but it's more about people.

What we're trying to accomplish is to serve people and create something that will help them with a task, their job, or even something that brings them joy. The technology doesn't mean anything for almost person it's serving as long as it fulfills what they want.

This is true for the user and it's also for development itself.

The business of creating software brings together a team of _people_ to solve a problem that serves other _people_.

The heart and soul of our business is people working with people to help other people.

But of course, this gets swallowed by the type of hyper-analytical, borderline obsessive mind required to be a software engineer.

Over my journey as an engineer I've tried to mentor and teach people how to be developers. My mantra is _anyone_ can be a developer, and that it's not nearly as hard as it's portrayed. Someone only needs to put in the effort and time as they would to try to learn any other skill.

Unfortunately experience has proven me wrong, and it's not because of an inability to learn the difference between a `.map` and a `.forEach` loop.

I'd say the number one trait that I've noticed in every successful developer is that we are addicted to the dopamine hit that comes from solving complex problems.

As a matter of fact, that addiction is so deep that we can tolerate days, weeks, and even months of frustration stubbornly attempting to solve a problem.

And while this may be our best trait, it can also be our worst.

The overwhelming desire that drives the essence of developers also leaks onto the technology itself, the tool becomes a focus of wonder and marvel. Each layer peels back to expose another treasure trove of titillating bemusement satiating the dopamine fix.

But this turns developers away from the people they're trying to solve for and instead turns the process inward and more about a developers depth of skill versus the connection with people.

It's like being a baker obsessed with their KitchenAid but wondering why no one wants to buy their cakes.

And I think it's this mentality that works its way into development teams and can often turn them toxic.

Looking back at the tl:dr; above:

> When you review a PR and come across something that doesn't seem right which mindset do you follow:
> > 1. This is wrong and I need to correct it, or
> > 2. This doesn't look right, but maybe I'm missing something? Let me reach out to the dev.

People in camp one are focused too much on their tools while people in camp two realize that their job is to collaborate with others.

The first is an Executioner, and not like "Bill is really good at executing the tasks that have been handed to him" but more instead wearing a black hood and carrying around a gigantic axe.

Most team members _dread_ when an executioner is assigned to review their PR.

Even though the code works and accomplishes what's been asked for, fits all Code Style Guides that has been laid out by the team and company policies, doesn't cause any bugs or issues, the Code Executioner will lop off the developer's head not because there's anything actually wrong, but _because it's not the way that they would do it._

This is born from non-collaborative perspectives, this is related to not caring about your teammates, their perspectives, and how they think things should be done, but rather is about one person being too engrossed in their own way of doing things to realize that there might actually be other ways to accomplish something.

Let me pose this in another way, and this is especially meant for anyone who might be suspecting they could be coming from the Execution direction, _do you think when a developer opens a PR they're doing it because they think they're doing it wrong?_

Or another way of putting it, _if a developer opens a PR do you think that they don't also think they're right?_

That's why this is such a tricky perspective to navigate, nobody opens PRs because they think it's wrong. Which means when another reviews the code you assuming that the other person isn't doing what they think is right will of course rub people the wrong way.

Everyone believes they are just as right as you when it comes to code. And, surprise surprise, the Code Executioner typically isn't helping but instead trying to correct something they're misunderstanding.

I think everyone has lived this, but you'll typically find yourself in a comment thread with someone who keeps bringing up an arbitrary point and every time you respond, trying to bring up why they're missing it, they continue to repeat and reinforce themselves.

In a perfect world the person leaving the comment would only do so in questions, which is why it's so much powerful for the commenter to come from the perspective that they're the ones who are misunderstanding and _not_ that the other person is wrong.

This is why the collaborative perspective matters so much. You are assuming that your coworkers know just as much as you do, and it's your job to understand them instead of trying to prove them wrong. Instead you as a reviewer are acknowledging that the other person is valid and so are their perspectives and you'd like to understand why _you as the reviewer_ aren't getting it.

I'd like to believe this mild tweak could great change the culture within a team of people who share a codebase, but _even if it didn't_, wouldn't it make your own working environment that much better?
